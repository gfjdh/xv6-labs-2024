1. 哪些寄存器保存函数参数？例如，在main调用printf时，哪个寄存器保存13？
在 RISC-V 调用约定中，函数参数通过寄存器传递：
前8个整数参数使用寄存器 a0 到 a7。
在 main 调用 printf 时：
  a0 保存格式字符串 "%d %d\n" 的地址（通过 auipc 和 addi 加载）。
  a1 保存第二个参数 f(8)+1（值为 12）。
  a2 保存第三个参数 13（通过 li a2, 13 加载）。
保存 13 的寄存器是 a2。

 2. 在main的汇编代码中，哪里调用了函数f？哪里调用了g？（提示：编译器可能内联函数）
在 main 的汇编代码中，没有显式调用 f 或 g 的指令（如 jal 或 jalr）。
原因：编译器进行了内联优化（inline optimization）。函数 f 和 g 的代码被直接内联到 main 中：
  f(8) 被计算为 g(8) = 8 + 3 = 11，然后 f(8) + 1 = 12。
  结果 12 直接通过 li a1, 12 加载到寄存器 a1（见地址 0x26）。
因此，函数调用被优化掉，没有跳转指令。

 3. printf函数位于什么地址？
在 main 的汇编代码中，printf 的调用指令是：
  
  30: 68c000ef           jal   6bc <printf>
  
jal 指令跳转到偏移量 0x68c 加上当前 PC（程序计数器）。当前 PC 是 0x30，计算目标地址：
  偏移量 0x68c 是相对于 PC 的有符号立即数。
  目标地址 = PC + offset = 0x30 + 0x68c = 0x6BC。
printf 函数的地址是 0x6BC。

 4. 在main中jalr跳转到printf后，ra寄存器中的值是什么？
在 main 中，使用的是 jal 指令（跳转并链接），不是 jalr。指令为：
  30: 68c000ef           jal   6bc <printf>
  
jal 指令的行为：
  将返回地址（下一条指令的地址）保存到 ra 寄存器。
  下一条指令是 exit(0) 的调用，位于地址 0x34（li a0, 0）。
因此，ra 寄存器的值被设置为 0x34。

 5. 运行以下代码的输出及端序问题
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, (char *)&i);
输出是什么？  

  输出是 HE110 World。  
  原因：
  57616 的十六进制是 0xE110，%x 输出 E110，所以 "H%x" → "HE110"。
  i = 0x00646c72 在小端序下的字节序列（低地址到高地址）为：
    字节 0: 0x72（ASCII 'r'）
    字节 1: 0x6c（ASCII 'l'）
    字节 2: 0x64（ASCII 'd'）
    字节 3: 0x00（字符串终止符）
  %s 从 (char *)&i 开始读取，直到遇到 0x00，输出字符串 "rld"。
  组合结果："HE110" + " Wo" + "rld" = "HE110 World"。

如果是大端序，为了得到相同输出，i应该设置为什么值？57616需要改变吗？  
  i 需要改为 0x726c6400。  
    原因：大端序下，高字节在低地址。要输出 "rld" 后跟终止符，字节序列必须为：
    地址 0: 0x72（'r'）
    地址 1: 0x6c（'l'）
    地址 2: 0x64（'d'）
    地址 3: 0x00（终止符）
    对应 32 位整数 i = 0x726c6400。
  57616 不需要改变，因为 %x 输出整数的十六进制值（0xE110），不依赖内存端序。

 6. 在以下代码中，'y='后面会输出什么？为什么会这样？
printf("x=%d y=%d", 3);

  y= 后面输出的值是未定义的（具体值不可预测），可能是任意整数。
  printf 的格式字符串要求两个整数参数（%d），但只提供了一个参数 3。
  调用约定中：
    第一个参数（3）通过 a1 传递。
    第二个参数（缺失）本应通过 a2 传递，但未设置。
  printf 会从 a2 寄存器读取值，但 a2 包含的是调用前的残留数据（取决于编译器和运行时状态）。
  这是未定义行为（Undefined Behavior），可能导致错误输出、崩溃或任意值。实际输出取决于寄存器 a2 的当前值。